# managsystem

> A Vue.js project

## Build Setup
## 第一模块 登录组件
## 登录组件表单数据验证
1. 为el-form通过属性绑定:rules指定一个rules校验对象
2. 在data数据中定义该对象，其每一个属性都是校验规则
3. 为不同表单的item项，通过prop="username"指定不同验证规则

## 实现表单重置
1. 在element UI组件文档中Form Methods中有一个方法
2. resetField 对整个表单进行重置，将所有字段值重置为初始值并移除校验结果
3. 那么问题是，如何拿到表单对象中所有的数据，然后调用该对象即可
4. 用ref=""来拿原生对象的值 
5. 点击重置按钮，触发事件@click,ref拿值，调用resetField重置
+ this.$refs.loginFormRef.resetFields();

## 登录前预校验
1. 目的：输入账号密码就直接点击登录时，不应该直接发起请求，而是在发起请求之前，对表单数据进行预验证，验证通过后，才允许它发起请求，否则直接提示用户不合法
2. 方法：在点击登录时，调用表单的某个函数进行预验证，看element UI组件文档中的方法validate()
3. 给登录绑定点击事件
    this.$refs.loginFormRef.validate(valid=>{
        console.log(valid);
      });

## 发起请求
1. 安装axios，引入(由于axios不是vue的插件，不能使用Vue.use().要通过控制原型链的方式来引入)
import axios from 'axios'
Vue.prototype.$http = axios;
接下来就各个页面的每个组件都可以用this直接访问$http发起ajax请求了
2. 设置请求根路径 以后便可以直接在后面写接口地址了
axios.defaults.baseURL = 'http://49.235.242.56:8888/api/private/v1/'
3. 根据发起请求后得到一个Promise，为了简化，用async和await，因为await只能用在被async修饰的方法中，所以要把await外面的箭头函数修饰成异步，这样可以直接拿到服务器返回的meta数据，根据状态码判定登录是否成功
## 弹框提示
1. element  UI弹框提示
2. 组件配置过程：导入import {Message} from 'element-ui'
Vue.prototype.$message = Message
这个message需要全局挂载，$message自定义属性，可以改名字合法就行，
后面不能改，意思是把弹窗组件挂载到了Vue的原型对象上，这样每个组件都可以
通过this访问到$message，进行弹框提示
3. 使用this.$message.error('登录失败!')

## 登录成功后的操作行为
1. 将成功后的token，保存到客户端的window.sessionStorage.serItem()中
+ 项目中除了登录之外的API接口，必须在登录之后才能访问
+ token只应在当前网站打开期间生效，所以将token保存在sessionStorage中
2. 通过编程式导航跳转到后台主页，路由地址为'/home'

## 路由导航守卫控制访问权限
1. 分析需求：当成功登录后跳转到/home，当我们把token清除，重新刷新页面
 发现依旧能访问到/home.因此需要路由导航守卫：
如果用户没有登录，但是直接通过特定的URL访问特定页面，需要重新导航到登录页面

## 退出
1. 分析原理：只需要销毁本地的token即可，这样后续的请求就不会携带token，得重新生成一个新的token才能访问页面
2. 方法：window.sessionStorage.clear()
    this.$router.push('/login')

## 第二模块 主页布局
## element-ui快速布局
1. header 区域布局
分析：左右布局，左边是logo和文字，右边是退出按钮，flex布局
内部span文字区域和左边被div包裹，为了让文字居中，给div也设置flex布局即可
2. 左侧菜单布局
通过接口，获取菜单数据
方法：通过axios请求拦截器添加token，保证拥有获取数据的权限
需要授权的 API ，必须在请求头中使用 `Authorization` 字段提供 `token` 令牌
+ 通过2层v-for循环，将左侧菜单结构渲染出来哦
+ 左侧菜单格式美化
3. 左侧菜单折叠与展开
如何让侧边栏的总体宽度也变小
`<el-aside :width="isCollapse ? '64px' : '200px' ">`
判断，当侧边栏菜单内容折叠时，让侧边栏总体宽度也变小，扩展时变大


## 第三模块 路由
1. 实现首页路由重定向 
2. 将左侧菜单改造为路由链接
在el-menu 中开启:router="true"或者router，模式
启用该模式会在激活导航时以 index 作为 path 进行路由跳转
在二级菜单处调用，因为path唯一，但是纯字符串，路由跳转必须以'/'开头
因此拼接一个路由地址el-menu-item :index="'/' + subItem.path"

## 第四模块 用户管理
1. 如何让点击二级菜单时高亮及其动态切换?
方法：每次点击二级菜单的链接时，应该先把其对应的地址保存到sessionStorage中，这样就把需要激活的链接保存起来了，当刷新页面时，可以从sessionStorage
中把这个值取出来，然后赋值给高亮设置default-active属性就行

## 绘制用户列表的基本ui结构
1. ui组件有面包屑组件，拷贝代码
2. 卡片视图组件
3. 带搜索的input输入框组件
此时发现文本框占满了屏幕的整个宽度，那么后面的按钮就没地方放了
方法；给它一个固定的宽度，UI组件中的栅格系统来绘制

## 获取用户列表数据
## 渲染用户列表数据
1. 用ui组件Table表格

## 为用户表格添加索引列
在第一行姓名之前加一个  
`<el-table-column type="index"></el-table-column>`
## 改造状态列的显示效果
1. 分析：在实际页面中，状态列是个开关，但是我从接口处得到的返回值却是
布尔值，因此要根据布尔值来表示状态，同样也是用状态代替布尔值
2. 方法：作用域插槽
`slot-scope="scope"`然后通过`{{scope.row}}`可以拿到所有的数据，包括状态
下面要做的是怎么把它渲染成开关。
方法：打开UI组件，有switch开关
`<el-switch v-model="scope.row.mg_state"></el-switch>`

## 通过自定义插槽的形式定义列的渲染
## 数据的分页效果
1. UI组件
## 用户状态的修改
1. 分析：当把用户列表中状态打开或者关闭时，刷新页面又回还原到初始状态
这是因为我们没有把状态同步到数据库中保存
2. 解决方法：同步到数据库
3. 步骤
+ 1)监听switch开关状态的改变：switch开关组件内有change事件
+ 2)调用对应的api接口，将这次状态的改变同步到数据库中即可

## 实现搜索功能
1. 分析需求：
当用户在搜索框中输入不同的名称之后，点击搜索按钮，可以根据指定的名称，搜索用户。
2. 方法：那么就要先把文本框和data中数据做双向绑定，在点击搜索按钮时调用可以获取用户列表的函数进行数据的查询
3. 为什么没有用过滤器的方法也能实现？
因为获取函数数据时，传入的第二个参数是对象，对象中有3个参数，通过双向绑定改变了query这个参数为'a'，那么它调回来的数据就是以相应的规则进行获取数据，只有以a开头的数据在列表中
4. 优化：
当输入搜索内容时，最后有一个x号，点击就可以使它清空，利用ui组件，只要给input输入框添加clearable就可以了。
此时，只清空了输入框的内容，但是没有清空列表里的。
clearable有一个clear事件，在点击由 clearable 属性生成的清空按钮时触发
给该事件绑定@clear="getUserList"获取用户列表数据的方法重新获取所有数据给列表即可

## 实现添加用户的功能
1. 分析需求：
点击添加用户，出现一个Dialog 对话框，element-ui组件，按需导入
2. 在添加对话框中，渲染一个添加用户的表单
在Form表单组件里，找到验证表单的组件，设置好对应项

## 实现自定义规则
1. 分析：邮箱和手机号的规则可以用正则表达式，这里面暂时是不正确的因为没有给他设置相应的规则 element-ui Form表单内有自定义校验规则的组件
2. 自定义的箭头函数就是个验证规则
方法：第一步，先定义一个箭头函数，并起名
在data中定义一个变量checkEmail，它的值指向箭头函数，箭头函数的形参中包含了3个变量，分别是规则，值和回调函数
第二步，在具体的规则中，通过validator来使用定义的规则
定义正则表达式，并test
## 添加用户表单的重置功能
1. 需求分析：
当点击取消或者确定时，表单关闭，但是在此打开时，还是上一次输入的情况，所以希望可以重置情况
2. 方法：在整个对话框关闭之后，重置表单就行了。
1)监听对话框的关闭事件
2)在关闭事件中，重置表单

## 添加用户的预验证功能
分析需求：
在点击确定按钮的时候不应该直接发送请求，而是在函数中先对表单进行预验证，验证通过了再
步骤：先对确定按钮绑定一个事件处理函数
validate 任一表单项被校验后触发
## 发起请求添加新用户
发起万请求后记得 //隐藏添加用户的对话框
            this.addDialogVisiable = false 
            //重新获取用户列表数据
            this.getUserList()

## 修改用户的操作
1. 分析需求：
当点击用户列表后的修改按钮时，跳出一个修改信息对话框(Dialog)，用户名是只读，其余可编辑，修改过后点击确定如果通过了验证，OK了
## 根据ID修改用户信息
先拿到id，怎么拿？
通过形参的方式传进来，在哪传？在修改事件单击按钮中传过来
## 修改表单后关闭的重置操作
监听对话框的close事件，在其处理函数中，重置表单
## 提交修改之前的表单预验证操作
## 修改成功三部曲
            //关闭对话框
            this.editDialogVisiable = false
            //刷新数据列表
            this.getUserList()
            //提示修改成功
            this.$message.success('更新用户信息成功')

## 删除用户操作
1. 分析需求：
当点击删除按钮时，弹出提示框，是否确认 删除
点取消，就提示取消，点确定就删除并提示删除成功
2. MessageBox弹框组件
Vue.prototype.$confirm = MessageBox.confirm 
注册，全局引用
3. 当点击确定是，发起请求删除用户信息(id)

## 除了分配角色以外，所有用户列表的功能均实现