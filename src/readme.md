# managsystem

> A Vue.js project

## Build Setup
## 第一模块 登录组件
## 登录组件表单数据验证
1. 为el-form通过属性绑定:rules指定一个rules校验对象
2. 在data数据中定义该对象，其每一个属性都是校验规则
3. 为不同表单的item项，通过prop="username"指定不同验证规则

## 实现表单重置
1. 在element UI组件文档中Form Methods中有一个方法
2. resetField 对整个表单进行重置，将所有字段值重置为初始值并移除校验结果
3. 那么问题是，如何拿到表单对象中所有的数据，然后调用该对象即可
4. 用ref=""来拿原生对象的值 
5. 点击重置按钮，触发事件@click,ref拿值，调用resetField重置
+ this.$refs.loginFormRef.resetFields();

## 登录前预校验
1. 目的：输入账号密码就直接点击登录时，不应该直接发起请求，而是在发起请求之前，对表单数据进行预验证，验证通过后，才允许它发起请求，否则直接提示用户不合法
2. 方法：在点击登录时，调用表单的某个函数进行预验证，看element UI组件文档中的方法validate()
3. 给登录绑定点击事件
    this.$refs.loginFormRef.validate(valid=>{
        console.log(valid);
      });

## 发起请求
1. 安装axios，引入(由于axios不是vue的插件，不能使用Vue.use().要通过控制原型链的方式来引入)
import axios from 'axios'
Vue.prototype.$http = axios;
接下来就各个页面的每个组件都可以用this直接访问$http发起ajax请求了
2. 设置请求根路径 以后便可以直接在后面写接口地址了
axios.defaults.baseURL = 'http://49.235.242.56:8888/api/private/v1/'
3. 根据发起请求后得到一个Promise，为了简化，用async和await，因为await只能用在被async修饰的方法中，所以要把await外面的箭头函数修饰成异步，这样可以直接拿到服务器返回的meta数据，根据状态码判定登录是否成功
## 弹框提示
1. element  UI弹框提示
2. 组件配置过程：导入import {Message} from 'element-ui'
Vue.prototype.$message = Message
这个message需要全局挂载，$message自定义属性，可以改名字合法就行，
后面不能改，意思是把弹窗组件挂载到了Vue的原型对象上，这样每个组件都可以
通过this访问到$message，进行弹框提示
3. 使用this.$message.error('登录失败!')

## 登录成功后的操作行为
1. 将成功后的token，保存到客户端的window.sessionStorage.serItem()中
+ 项目中除了登录之外的API接口，必须在登录之后才能访问
+ token只应在当前网站打开期间生效，所以将token保存在sessionStorage中
2. 通过编程式导航跳转到后台主页，路由地址为'/home'

## 路由导航守卫控制访问权限
1. 分析需求：当成功登录后跳转到/home，当我们把token清除，重新刷新页面
 发现依旧能访问到/home.因此需要路由导航守卫：
如果用户没有登录，但是直接通过特定的URL访问特定页面，需要重新导航到登录页面

## 退出
1. 分析原理：只需要销毁本地的token即可，这样后续的请求就不会携带token，得重新生成一个新的token才能访问页面
2. 方法：window.sessionStorage.clear()
    this.$router.push('/login')

## 第二模块 主页布局
## element-ui快速布局
1. header 区域布局
分析：左右布局，左边是logo和文字，右边是退出按钮，flex布局
内部span文字区域和左边被div包裹，为了让文字居中，给div也设置flex布局即可
2. 左侧菜单布局
通过接口，获取菜单数据
方法：通过axios请求拦截器添加token，保证拥有获取数据的权限
需要授权的 API ，必须在请求头中使用 `Authorization` 字段提供 `token` 令牌
+ 通过2层v-for循环，将左侧菜单结构渲染出来哦
+ 左侧菜单格式美化
3. 左侧菜单折叠与展开
如何让侧边栏的总体宽度也变小
`<el-aside :width="isCollapse ? '64px' : '200px' ">`
判断，当侧边栏菜单内容折叠时，让侧边栏总体宽度也变小，扩展时变大


## 第三模块 路由
1. 实现首页路由重定向 
2. 将左侧菜单改造为路由链接
在el-menu 中开启:router="true"或者router，模式
启用该模式会在激活导航时以 index 作为 path 进行路由跳转
在二级菜单处调用，因为path唯一，但是纯字符串，路由跳转必须以'/'开头
因此拼接一个路由地址el-menu-item :index="'/' + subItem.path"

## 第四模块 用户管理
1. 如何让点击二级菜单时高亮及其动态切换?
方法：每次点击二级菜单的链接时，应该先把其对应的地址保存到sessionStorage中，这样就把需要激活的链接保存起来了，当刷新页面时，可以从sessionStorage
中把这个值取出来，然后赋值给高亮设置default-active属性就行

## 绘制用户列表的基本ui结构
1. ui组件有面包屑组件，拷贝代码
2. 卡片视图组件
3. 带搜索的input输入框组件
此时发现文本框占满了屏幕的整个宽度，那么后面的按钮就没地方放了
方法；给它一个固定的宽度，UI组件中的栅格系统来绘制

## 获取用户列表数据
## 渲染用户列表数据
1. 用ui组件Table表格

## 为用户表格添加索引列
在第一行姓名之前加一个  
`<el-table-column type="index"></el-table-column>`
## 改造状态列的显示效果
1. 分析：在实际页面中，状态列是个开关，但是我从接口处得到的返回值却是
布尔值，因此要根据布尔值来表示状态，同样也是用状态代替布尔值
2. 方法：作用域插槽
`slot-scope="scope"`然后通过`{{scope.row}}`可以拿到所有的数据，包括状态
下面要做的是怎么把它渲染成开关。
方法：打开UI组件，有switch开关
`<el-switch v-model="scope.row.mg_state"></el-switch>`

## 通过自定义插槽的形式定义列的渲染
## 数据的分页效果
1. UI组件
## 用户状态的修改
1. 分析：当把用户列表中状态打开或者关闭时，刷新页面又回还原到初始状态
这是因为我们没有把状态同步到数据库中保存
2. 解决方法：同步到数据库
3. 步骤
+ 1)监听switch开关状态的改变：switch开关组件内有change事件
+ 2)调用对应的api接口，将这次状态的改变同步到数据库中即可

## 实现搜索功能
1. 分析需求：
当用户在搜索框中输入不同的名称之后，点击搜索按钮，可以根据指定的名称，搜索用户。
2. 方法：那么就要先把文本框和data中数据做双向绑定，在点击搜索按钮时调用可以获取用户列表的函数进行数据的查询
3. 为什么没有用过滤器的方法也能实现？
因为获取函数数据时，传入的第二个参数是对象，对象中有3个参数，通过双向绑定改变了query这个参数为'a'，那么它调回来的数据就是以相应的规则进行获取数据，只有以a开头的数据在列表中
4. 优化：
当输入搜索内容时，最后有一个x号，点击就可以使它清空，利用ui组件，只要给input输入框添加clearable就可以了。
此时，只清空了输入框的内容，但是没有清空列表里的。
clearable有一个clear事件，在点击由 clearable 属性生成的清空按钮时触发
给该事件绑定@clear="getUserList"获取用户列表数据的方法重新获取所有数据给列表即可

## 实现添加用户的功能
1. 分析需求：
点击添加用户，出现一个Dialog 对话框，element-ui组件，按需导入
2. 在添加对话框中，渲染一个添加用户的表单
在Form表单组件里，找到验证表单的组件，设置好对应项

## 实现自定义规则
1. 分析：邮箱和手机号的规则可以用正则表达式，这里面暂时是不正确的因为没有给他设置相应的规则 element-ui Form表单内有自定义校验规则的组件
2. 自定义的箭头函数就是个验证规则
方法：第一步，先定义一个箭头函数，并起名
在data中定义一个变量checkEmail，它的值指向箭头函数，箭头函数的形参中包含了3个变量，分别是规则，值和回调函数
第二步，在具体的规则中，通过validator来使用定义的规则
定义正则表达式，并test
## 添加用户表单的重置功能
1. 需求分析：
当点击取消或者确定时，表单关闭，但是在此打开时，还是上一次输入的情况，所以希望可以重置情况
2. 方法：在整个对话框关闭之后，重置表单就行了。
1)监听对话框的关闭事件
2)在关闭事件中，重置表单

## 添加用户的预验证功能
分析需求：
在点击确定按钮的时候不应该直接发送请求，而是在函数中先对表单进行预验证，验证通过了再
步骤：先对确定按钮绑定一个事件处理函数
validate 任一表单项被校验后触发
## 发起请求添加新用户
发起万请求后记得 //隐藏添加用户的对话框
            this.addDialogVisiable = false 
            //重新获取用户列表数据
            this.getUserList()

## 修改用户的操作
1. 分析需求：
当点击用户列表后的修改按钮时，跳出一个修改信息对话框(Dialog)，用户名是只读，其余可编辑，修改过后点击确定如果通过了验证，OK了
## 根据ID修改用户信息
先拿到id，怎么拿？
通过形参的方式传进来，在哪传？在修改事件单击按钮中传过来
## 修改表单后关闭的重置操作
监听对话框的close事件，在其处理函数中，重置表单
## 提交修改之前的表单预验证操作
## 修改成功三部曲
            //关闭对话框
            this.editDialogVisiable = false
            //刷新数据列表
            this.getUserList()
            //提示修改成功
            this.$message.success('更新用户信息成功')

## 删除用户操作
1. 分析需求：
当点击删除按钮时，弹出提示框，是否确认 删除
点取消，就提示取消，点确定就删除并提示删除成功
2. MessageBox弹框组件
Vue.prototype.$confirm = MessageBox.confirm 
注册，全局引用
3. 当点击确定是，发起请求删除用户信息(id)

## 除了分配角色以外，所有用户列表的功能均实现

## 权限管理模块
1. 先依据前面的做法，渲染表格和数据
2. 权限管理业务分析
每个用户拥有不同的角色，每个角色有不同的功能权限
3. 角色列表路由的切换
分析需求，点击角色列表时，可以在主体区域展示组件
角色列表布局及渲染数据
添加角色重复，待会在做

## 扩展如何做
1. 分析需求，当点击扩展时，会展示角色的权限
因此要先拿到角色名称下其所有权限(children属性)
通过作用域插槽来拿
通过scope.row拿到对应的角色信息，然后通过3层for循环渲染，每一层给一个颜色tag标签
2. 先分页面结构在渲染1级(layout栅格布局)

## 分配权限
树形控件
1. 优化属性控件。因为我的树形控件不能复选
怎么在树形控件每一个节点之前加复选框呢？
ui中写到添加一个show-checkbox即可
2. 给树形节点添加唯一表示，ui属性node-key="id"
3. 怎么设置让分配权限进去就全展开而不是缩略？
default-expand-all	是否默认展开所有节点 true
4. 已有的默认勾选
ui组件有属性：:default-expanded-keys="defKeys"	默认展开的节点的 key 的数组	
具体方法：定义一个递归函数。然后把角色信息传到递归的函数中，通过递归的形式，把三级
节点的id保存到一个数组中，再把这个数组复制给defKeys
1)先判断它是不是三级节点：是否包含children属性
2)再递归操作
5. 小bug
因为勾选后，当你点别的节点时，会发现包括之前的，这是因为我点击别的节点时，关闭对话框时，上一次的数组没有清空的原因
方法：监听对话框关闭事件，清空数组
6. 分析：当我勾选了或者取消了某些权限时，点击确定时（绑定函数），向服务器发起一次请求。保存到服务器中，让数据持久化
注意：点击复选框后，应api要求，需要保存已选中和半选中的id，都形成一个字符串，中间以逗号分隔，通过tree组件提供的2个函数实现
getCheckedKeys	若节点可被选择（即 show-checkbox 为 true），则返回目前被选中的节点的 key 所组成的数组
getHalfCheckedKeys	若节点可被选择（即 show-checkbox 为 true），则返回目前半选中的节点的 key 所组成的数组

## 商品分类模块
1.  商品分类路由的加载 
创建cate路由
2. 绘制商品分类页面的基本结构
面包屑 卡片视图，卡片视图内有 表格区 分页区
3. 获取商品分类数据列表
4. 将商品分类的数据渲染成树形表格
vue-table-with-tree-grid
npm i vue-table-with-tree-grid -S
import TreeTable from 'vue-table-with-tree-grid'
Vue.component(tree-table, TreeTable)
具体用法，网站有写
5. 自定义插槽，做自定义渲染。如果cate_delete为true时是对钩，为false时为错。用2个图标显示，v-if判断状态值，对就是对钩，错就是错圈
6. 排序和操这两列
7. 商品分类的分页效果
首先在页面中渲染分页的页码条 el-ui page分页el-pagination
8. 添加分类操作
点击添加分类按钮，出现1个对话框，对话框里有2个带有验证规则的表单项，第一个是分类名称，第二个是父级分类，它是个选择框
9. 渲染父级分类，ui组件中的级联选择器
10. 添加分类的表单数据
分析，当只输入名称不选择分类时，那么addCateForm这个添加分类表单数据对象里的三个值
应该分别为名称，0和0，它是一级分类
如果选择了二级分类，那么它就是名称。1和1.
如果选择了三级分类，那么就是3 和2
因此要给选中项做判断，如果selectedKeys数组中的length大于0，则证明选中了父级分类
反之没有选中任何父级分类
父级分类的id
11. 添加分类对话框关闭事件
清空对话框
先给对话框绑定一个close事件，然后拿到ref引用，this.$refs.addCateFormRef.resetFields()
注意这样只能清空表单，但是无法清空级联选择器中的内容，应该把这个也清空
清空数组和表单对象里的内容也清空
12. 点击确定事件
对表单进行预验证，通过后就发起请求，添加新的分类


## 分类参数管理
1. 先创建对应的路由
2. 绘制基本视图
3. 获取商品分类的数据，api
4. 渲染商品分类的级联选择框
5. 只能选三级的，不能选1，2级，因此控制级联选择器的范围
方法：只要监听选择器的change事件，在change事件中判断数组长度是否为3
因为v-model与选择器绑定了，因此如果选择后不等于3，就清空数组
6. 渲染添加参数的按钮和添加属性的按钮，及其禁用和启用的
当选择了三级时，启用，否则禁用
方法：定义一个计算属性，如果数组长度为3，Boole值为真，控制它的开关
7. 根据参数的分类：动态还是静态 以及所选的商品分类，获取对应的数据 api
在选择项选择后(change事件)就发起请求
注意，因为绑定在change事件，是级联选择器发生改变是，但是面板发生改变时，并未触发，因此这是个小bug修改下
方法：可以把它抽离为一个函数，不管谁发生变化，调用它就好
又有一个问题，因为每次调用getParamsData()这个方法，数据都会存在res.data中，那么动态参数和静态属性都在这，到底哪一个是哪一个呢？
方法：并不直接保存到data上，先做一下判断，判断到底是那个表格的数据在存在分别的对象上
8. 渲染动态和静态的table表格
9. 完成点击添加参数的功能
因为添加属性与添加参数一样，因此可以共用一个对话框，提高下代码难度
10. 点击修改弹出对话框，并把对应的数据传到对话框内容中
方法：穿id绑定到对话框中就可
11. 删除
为删除按钮绑定事件，id
12. 控制添加按钮和输入文本框的切换显示
v-if   el-ui
bug：当点击一行时，其余各行的数据也会显示输入框，和内容
原因：每次循环时，都共用布尔值显示与隐藏，因此会产生联动
方法：为每一行数据单独提供布尔值就行
nextTick作用：当页面上元素被重新渲染之后，才可以指定回调函数中代码
当文本框失去焦点时，变成按钮，如何实现？
为失去焦点绑定事件即可


##  商品列表功能
1. 如何控制级联选择器的范围？
给级联选择器的数据数组判断长度范围，是否==3 ，如果是，则选择的是第三级，否则就给数据数组清空，重新选 
2. 如何阻止标签页的切换？
首先要监听标签页的切换事件，先判断此时时候处于第一个标签页，同时还要判断选中的商品分类是否是三级分类
el-ui标签页组件中有before-leave属性，2个参数在el-tabs中绑定:before-leave
只要return false就会阻止标签页的切换，但是会一直阻止，因此要有条件的阻止
if(oldActiveName === '0' && this.addForm.goods_cat.length !== 3) {
return false}
3. 获取商品参数对应的数据
给tabs绑定一个事件，组件自带@tab-click="tabClicked"当点击tab标签时触发的函数，因为api中有id需求，id是`this.addForm.goods_cat[2]`，有点麻烦 ，可以设置计算属性computed,方便调用
`cateId(){if(this.addForm.goods_cat.length === 3){return this.addForm.goods_cat[2]} return null}`
拿到数据后，将数据保存在data上，从而供页面渲染
`el-form-item v-for="item in manyTableData"`
el组件多选框组 加边框border即可
优化：发现这样的复选框大小不一致，版式不好看，打开检查元素发现各个复选框大小margin都不一致，因此可以给`.el-checkbox{margin:0 10px 0 0 !important}`
4. 商品属性
接着之前的写，如果当前页是首页且点了第二个，则切换到商品属性，发起请求获得静态属性数据
通过循环的形式渲染数据
每一个item项都需要一个文本输入框，则在el-form-item 内放el-input,`v-model=""`
5. 商品图片：图片上传功能
分析：当你点击商品图片时.弹出一个选择图片的对话框，当你选择一张图片后，他会自动将其上传到后台的api中。当你想看这个图片的时候，会出现一个图片预览 的对话框,当你选择了一张图片后，它会自动选择该图片上传到api服务器中，如果想看该图片的效果，可以单击图片，会出现一个叫图片预览的对话框，可以看到图片的具体内容，然后可以关闭预览窗口。如果你不满意该图片，你可以吧鼠标放到该图片上，图片右上角单击叉号，就能将图片从上传列表中移出。
怎么实现？
上传组件Upload上传,
移除数组的逻辑：当点击叉号时，触发移除事件，拿到对应被移除图片的对应信息，
根据图片的临时路径，从数组中找到这一项的索引值，然后从pics数组中删除就好、

预览功能：
先监听el-upload中的on-preview事件，在事件处理函数中接收到了图片信息，得到完整的图片路径，在对话框窗口中动态绑定一个图片地址
6. 富文本编辑区
下载安装依赖npm install vue-quill-editor -S
在main.js导入编辑器及对应的样式，然后vue.use注册为全局可用的组件
把内容双向绑定到addForm中

下载lodash深拷贝
 
 ## 订单管理功能开发
